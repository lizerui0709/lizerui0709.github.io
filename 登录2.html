<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>爱心跳动 (HTML5 Canvas)</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: black;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }
        canvas {
            border: 1px solid #333;
        }
    </style>
</head>
<body>
    <canvas id="heartCanvas" width="1200" height="800"></canvas>

    <script>
        const canvas = document.getElementById('heartCanvas');
        const ctx = canvas.getContext('2d');

        // --- 1. 常量定义 (与C++代码对应) ---
        const xScreen = 1200;
        const yScreen = 800;
        const PI = Math.PI;
        const e = Math.E;
        const averag_distance = 0.162;
        const frames = 20; // 动画帧数

        // 颜色数组
        const colors = [
            'rgb(255,32,83)',
            'rgb(252,222,250)',
            'rgb(255,0,0)',
            'rgb(255,0,0)',
            'rgb(255,2,2)',
            'rgb(255,0,8)',
            'rgb(255,5,5)'
        ];
        
        // --- 2. 工具函数 ---
        
        // 坐标转换：数学坐标 -> Canvas屏幕坐标
        function screenX(x) {
            return x + xScreen / 2;
        }
        
        function screenY(y) {
            // Canvas的Y轴向下，所以需要取反
            return -y + yScreen / 2;
        }

        // 生成 [x1, x2] 之间的随机整数
        function creatRandom(x1, x2) {
            if (x2 > x1) {
                return Math.floor(Math.random() * (x2 - x1 + 1)) + x1;
            }
            return 0;
        }
        
        // --- 3. 核心数据生成 ---
        
        // 3.1. 生成原始爱心的轮廓点 (origin_points)
        const originPoints = [];
        let x1 = 0, y1 = 0; // 用于计算点间距
        for (let radian = 0.1; radian <= 2 * PI; radian += 0.005) {
            // 爱心参数方程
            const x2 = 16 * Math.pow(Math.sin(radian), 3);
            const y2 = 13 * Math.cos(radian) - 5 * Math.cos(2 * radian) - 2 * Math.cos(3 * radian) - Math.cos(4 * radian);

            const distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
            if (distance > averag_distance) {
                x1 = x2;
                y1 = y2;
                originPoints.push({x: x2, y: y2});
            }
        }
        const quantity = originPoints.length; // 实际生成的点数

        // 3.2. 生成爱心主体的所有粒子点 (points)
        const points = [];
        for (let size = 0.1; size <= 20; size += 0.1) {
            const success_p = 1 / (1 + Math.pow(e, 8 - size / 2));
            for (let i = 0; i < quantity; ++i) {
                if (success_p > Math.random()) { // 直接用Math.random()与概率比较
                    const color = colors[creatRandom(0, 6)];
                    const x = size * originPoints[i].x + creatRandom(-4, 4);
                    const y = size * originPoints[i].y + creatRandom(-4, 4);
                    points.push({x, y, color});
                }
            }
        }
        const pointsSize = points.length;

        // 3.3. 预计算所有动画帧 (images数组的概念)
        const framesData = []; // 每个元素存储一帧的所有点数据
        let currentPoints = JSON.parse(JSON.stringify(points)); // 深拷贝，避免修改原始数据

        for (let frame = 0; frame < frames; ++frame) {
            const framePoints = []; // 当前帧的主体点
            const outerPoints = []; // 当前帧的外围闪烁点

            // a. 计算主体点的扩张
            for (let i = 0; i < pointsSize; ++i) {
                const x = currentPoints[i].x;
                const y = currentPoints[i].y;
                const distance = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
                const diatance_increase = -0.0009 * distance * distance + 0.35714 * distance + 5;
                
                // 每帧的增量
                const x_increase = diatance_increase * x / distance / frames;
                const y_increase = diatance_increase * y / distance / frames;

                // 更新并保存
                currentPoints[i].x += x_increase;
                currentPoints[i].y += y_increase;
                framePoints.push({...currentPoints[i]}); // 保存当前状态
            }

            // b. 计算外围闪烁点
            for (let size = 17; size < 23; size += 0.3) {
                for (let i = 0; i < quantity; ++i) {
                    let pass = false;
                    if (size >= 20) {
                        pass = Math.random() > 0.6; // 60%概率出现
                    } else {
                        pass = Math.random() > 0.95; // 5%概率出现
                    }

                    if (pass) {
                        let x, y;
                        if (size >= 20) {
                            const offset = -frame * frame / 5 - 15;
                            const range = frame * frame / 5 + 15;
                            x = originPoints[i].x * size + creatRandom(offset, range);
                            y = originPoints[i].y * size + creatRandom(offset, range);
                        } else {
                            x = originPoints[i].x * size + creatRandom(-5, 5);
                            y = originPoints[i].y * size + creatRandom(-5, 5);
                        }
                        const color = colors[creatRandom(0, 6)];
                        outerPoints.push({x, y, color});
                    }
                }
            }

            framesData.push({framePoints, outerPoints});
        }

        // --- 4. 动画播放 ---
        
        let currentFrame = 0;
        let isExtend = true; // 标记是扩张还是收缩
        let animationId;

        // 绘制单帧的函数
        function draw() {
            // 清空画布
            ctx.clearRect(0, 0, xScreen, yScreen);

            const data = framesData[currentFrame];

            // 绘制主体粒子
            data.framePoints.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(screenX(p.x), screenY(p.y), 1, 0, 2 * PI);
                ctx.fill();
            });

            // 绘制外围闪烁粒子
            data.outerPoints.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(screenX(p.x), screenY(p.y), 1, 0, 2 * PI);
                ctx.fill();
            });

            // 更新帧索引
            if (isExtend) {
                currentFrame++;
                if (currentFrame >= frames) {
                    currentFrame = frames - 2; // 回退两格，准备开始收缩
                    isExtend = false;
                }
            } else {
                currentFrame--;
                if (currentFrame < 0) {
                    currentFrame = 1; // 前进两格，准备开始扩张
                    isExtend = true;
                }
            }

            // 请求下一帧
            animationId = requestAnimationFrame(draw);
        }

        // 按任意键停止动画
        document.addEventListener('keydown', () => {
            cancelAnimationFrame(animationId);
            console.log('动画已停止。');
        });
        
        // 开始动画
        draw();
    </script>
</body>
</html>